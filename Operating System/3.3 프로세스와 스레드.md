# 프로세스와 스레드

## 📌 면접 예상 질문

<details>
  <summary>Q1. 프로세스와 프로세서의 차이를 말씀해 주세요.</summary>
  </br>

### 프로세스
- 컴퓨터에서 실행중인 프로그램
- 각자 고유한 공간과 자원을 할당받는다.
- 각각의 code, data, stack, heap 영역을 보유
- 각각의 영역을 갖기에 동기화 작업이 필요하지 않음.
  - 따라서 Context Switching 비용이 크다.

### 프로세서
- 연산을 수행하는 하드웨어 장치 (CPU)
- 여러 개의 프로세스를 동시에 실행할 수 있음 (멀티코어 프로세서)
- 프로세스의 명령어를 해석하고 실행하는 역할

### 결론
> 프로세스는 실행 중인 프로그램이고,  
> 프로세서는 그 프로그램을 실행하는 하드웨어(CPU)이다.

### 결론

</details>

<details>
  <summary>Q2. 프로세스와 스레드의 차이를 말씀해 주세요.</summary>
  </br>

### 프로세스
- 컴퓨터에서 실행중인 프로그램
- 각자 고유한 공간과 자원을 할당받는다.
- 각각의 code, data, stack, heap 영역을 보유
- 각각의 영역을 갖기에 동기화 작업이 필요하지 않음.
  - 따라서 Context Switching 비용이 크다.

### 스레드
- 한 프로세스 내의 실행 단위
- stack만 고유한 영역을 갖고 나머지 영역은 프로세스 자원을 공유
- stack 이외의 영역을 공유하므로 동기화 작업이 필요
  - 따라서 Context Switching 비용이 적다.

### 결론  
> **프로세스**는 실행 중인 프로그램이고,  
> **스레드**는 그 프로그램 내에서 실행되는 작업 단위이다.  
> 예시) **크롬 브라우저(프로세스) - 각 탭에서 실행되는 영상(스레드)**  

</details>

<details>
  <summary>Q3. 멀티 스레드와 멀티 프로세스의 차이를 말씀해 주세요.</summary>

### 멀티 스레드  
- 하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하면서 작업을 수행하는 방식  
- 멀티 프로세스보다 적은 메모리 공간을 차지하고, **Context Switching**이 빠름  
- 하지만 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있으며, **동기화 문제**가 발생할 수 있음  

### 멀티 프로세스  
- 하나의 프로그램을 여러 개의 프로세스로 구성하여 병렬적으로 작업을 수행하는 방식  
- 하나의 프로세스가 종료되더라도 다른 프로세스에 영향을 주지 않는 장점이 있음  
- 하지만 멀티 스레드보다 **메모리 사용량이 많고, Context Switching 비용이 큼**  

### 결론
> 멀티 프로세스는 안정적이지만 무겁고,  
> 멀티 스레드는 가볍지만 동기화 문제가 있을 수 있다.

</details>


<details>
  <summary>Q4. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유에 대해 말씀해 주세요.</summary>

### 멀티 스레드를 사용하는 이유  
- **여러 개의 프로그램을 실행하는 것보다, 하나의 프로그램 내에서 여러 작업을 수행하는 것이 더 효율적임**  
  - **Context Switching 시 Stack 영역만 초기화하면 되므로 속도가 빠름**  
  - **프로세스 간 메모리 공유가 불가능하지만, 스레드는 메모리를 공유하여 자원 활용이 효율적임**  

</details>

---

## 📌 내용 정리

### 프로세스(Process)
- 메모리상에서 실행 중인 프로그램
- 실행 중인 프로그램은 최소 1개의 스레드를 가짐 (메인 스레드)

### 스레드(Thread)
- 프로세스 내에서 실행되는 여러 흐름 단위
- 프로세스 내에서 동일한 자원(메모리, 변수 등)을 공유하여 효율적

---

## 1. 컴파일 과정
![컴파일](https://velog.velcdn.com/images/narangke3/post/a9daf66d-aab5-41a7-b8c0-268b535ea7a2/image.png)

1. 프로그램(.exe) 실행 (프로세스 시작)
2. 전처리: 주석 제거, 매크로 치환 등
3. 컴파일러: 고급 언어를 어셈블리어로 변환
4. 어셈블러: 어셈블리어를 기계어(오브젝트 파일)로 변환
5. 링커: 여러 오브젝트 파일을 하나의 실행 파일(.exe or .out)로 결합

---

## 2. 프로세스의 상태
![프로세스의 상태](https://many258.github.io/assets/images/OS/process-state-diagram.png)
### ㄱ. 생성 상태 (new)
> 프로세스가 생성된 상태. **PCB가 할당**. fork() or exec() 함수를 통해 생성
- fork(): 부모 프로세스의 주소공간을 그대로 복사해서 자식 프로세스 생성. 주소 공간만 복사. 상속x
- exec(): 새롭게 프로세스를 생헝하는 함수

### ㄴ. 대기 상태 (ready)
> 메모리 공간이 충분하면 메모리 할당. 아니면 대기 상태. CPU 스케줄러로부터 CPU 소유권 넘어오기를 대기.
### ㄷ. 대기 중단 상태 (ready suspended )
> 메모리 부족으로 질시 중단된 상태
### ㄹ. 실행 상태 (running)
> CPU 소유권과 메모리를 할당받고 인스트럭션을 수행중인 상태. (= CPU burst가 일어났다.)
### ㅁ. 중단 상태 (wait or block)
> 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태. I/O에 의한 인터럽트로 자주 발생. (ex. 인쇄시 잠깐 멈추는 듯한 느낌)
### ㅂ. 일시 중단 상태 (blocked suspended)
> 대기 중단과 유사. 메모리 부족
### ㅅ. 종료 상태 (exit)
> 메모리와 CPU 소유권을 모두 놓고 가는 상태. 자연스럽게 종료되는 것과 부모 프레세스가 자식 프로세스를 강제적으로 비자발적 종료 시키는 경우도 있음 (abort)

---

## 3. 프로세스의 메모리 구조
![메모리 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlKO90%2FbtsES2rvS7a%2FfSkKomTeo1ZJepCJDnFl61%2Fimg.png)

### 동적 영역 
#### ㄱ. 스택 (Stack)
- 지역변수, 매개변수, 함수가 저장. 함수가 재귀적으로 호출하면서 동적으로 크기가 늘어날 수 있으므로 힙과 스택이 겹치지 않기 위해 힙과 스택사이의 공간을 비워놓음.
- 컴파일 시 크기가 결정됨
#### ㄴ. 힙 (Heap)
- 동적 할당할 때 사용 됨 (ex. 벡터 같은 동적 배열)
- 런타임 시 크기가 결정됨

### 정적 영역
#### ㄷ. 데이터 영역
전역변수, 정적변수가 저장. 프로그램이 종료되면서 사라지는 변수
- BSS segment: 초기화가 되지 않은 변수가 0으로 초기화되어 저장.
- Data Segment: 0이 아닌 다른 값으로 할당된 변수들이 저장.
#### ㄹ. 코드 영역 (Code Segment)
프로그램에 내장되어 있는 소스코드가 들어가는 영역. 수정 불가능한 기계어로 되어있음

---

## 4. PCB

### PCB (Process Control Block)의 구조
운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터. (aka.프로세스 제어 블록). 커널 스택의 가장 앞부분에서 관리(일반 사용자 접근X)
프로세스 생성 ->  
스택, 힘등의 구조를 기반으로 메모리 할당 ->  
PCB에 메타데이터 저장되어 관리

- 프로세스 상태: 프로세스가 CPU에 대한 소유권을 얻은 이후 상태(준비, 일시 중단 등)
- 프로세스 ID: 해당ID, 자식ID
- 프로세스 권한: 리소스 또는 I/O 디바이스에 대한 권한 정보
- 프로그램 카운터: 실행할 다음 명령어의 주소 포인터
- CPU 레지스터: 저장해야 할 레지스터 정보
- CPU 스케줄링 정보: 스케줄러에 의해 중단된 시간 등 정보
- 계정 정보: 프로세스 실행에 사용된 CPU 사용량, 유저 정보
- I/O 상태 정보: 프로세스에 할당된 I/O 디바이스 목록

### 컨텍스트 스위칭 (Context Switching)
- 하나의 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 과정 (PCV 교환)
- PCB에 현재 실행 중인 프로세스 상태를 저장하고 새로운 프로세스를 로드
- 많은 프로그램을 실행하는 것 같이 보이지만, 빠르게 Context Switching이 되고 있는 것임. 실제로는 한개의 프로세스가 실행중인 것(싱글 코어 기준)  
![switching](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc3wWnK%2Fbtq2NcrH2wm%2FYikhwPpGK6p8Yu72QmDxi1%2Fimg.jpg)
- P0 가 실행중인 상태에서 idle이 될 때 P1이 곧바로 실행되지 않고 idle 하다가 실행된다
  - P0의 상태를 PCB에 저장하고 P1을 PCB에서 가져와야 하는데 이 과정에서 CPU가 아무 일도 못하기 때문
    - 성능 저하 발생
> 스레드는 스택을 제외한 모든 메모리를 공유하기 때문에 프로세스에 비해 리소스 소모가 적다.

---

## 5. 멀티프로세싱
- 여러 개의 프로세스를 동시에 실행하는 기법
- CPU 코어를 여러 개 활용하는 방식
#### ㄱ 웹브라우저
각 탭을 독립된 프로세스로 실행하여 안정성 확보
#### ㄴ IPC (Inter Process Communication)
  - 공유 메모리: 여러 프로세스에 동일한 메모리 블록에 대한 접근 권하을 부여하여 프로세스가 서로 통신할 수 있도록 하는 것
    - 불필요한 데이터 복사의 오버헤드가 없어 빠르다. 같은 메모리를 공유하기 때문에 동기화가 필요.
  - 파일: 디스크/서버에 저장된 데이터를 통해 통신
  - 소켓: 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 통신(TCP/UDP)
  - 익명 파이프: 프로세스간 FIFO 방식으로 데이터 통신. 단방향. 읽기or쓰기 전용. 부모 자식 간에만 가능. 다른 네트워크 상에서 불가능
  - 명명된 파이프: 단방향 or 이중 파이프. 여러 파이프 동시 사용 가능. 프로세스끼리, 다른 네트워크 컴퓨터와 통신 가능
  - 메시지 큐

---

## 6. 스레드와 멀티스레딩

#### ㄱ 스레드
프로세스 내에서 실행되는 독립적인 흐름, 같은 프로세스의 스레드는 메모리를 공유함
#### ㄴ 멀티스레딩
하나의 프로세스에서 여러 개의 스레드를 실행하는 기법, CPU 활용도를 높이고 응답성을 개선함
스레드끼리 리소스를 공유하여 효율성이 높음.

---

## 7. 공유자원과 임계 영역

#### 공유 자원
공유 자원(shared resource)은 시스템 안에서 각 프로세스, 스레드가
함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자
원이나 변수 등을 의미합니다. 이 공유 자원을 두 개 이상의 프로세
스가 동시에 읽거나 쓰는 상황을 경쟁 상태(race condition)라고 합니
다. 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결괏값에
영향을 줄 수 있는 상태인 것이죠.

#### 임계 영역
  - 뮤텍스: 사용하기 전에 잠금. 사용후 해제 (잠금 or 잠금해제의 상태만 가짐)
  - 세마포어: 일반화된 뮤텍스. 신호를 기반으로 상호배제가 일어나는 신호 메커니즘
    - wait(): 대기
    - signal(): 다음 프로세스로 넘김
  - 바이너리 세마포어: 0, 1 두가지 값만 갖는 세마포어
  - 카운팅 세마포어: 여러개의 값을 갖는 세마포어
  - 모니터: 모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공.


## 8. 교착 상태 (deadlock)
> 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태.

#### 원인
- 상호 배제: 한 프로세스가 자원을 독점하며 다른 프로세스들은 접근이 불가능.
- 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태.
- 비선점: : 다른 프로세스의 자원을 강제적으로 가져올 수 없음.
- 환형 대기: A가 B를, B가 A를 서로 요구하는 상태.

#### 해결방법
1. **자원 할당 방지**: 애초에 교착 상태가 발생하지 않도록 설계
2. **은행원 알고리즘 (Banker’s Algorithm)**: 프로세스가 요청할 최대 자원량을 기준으로 할당
3. **교착 상태 감지 및 회복**: 교착 상태 발생 시, 프로세스를 강제 종료하여 해결
4. **교착 상태 무시**: 교착 상태 발생 확률이 낮을 경우, 이를 감수하고 운영 (ex. 현대 운영체제)