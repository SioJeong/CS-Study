# CPU 스케줄링 알고리즘

## 📌 면접 예상 질문

<details>
  <summary>Q1. 선점형 방식과 비선점형 방식의 차이를 말씀해주세요.</summary>
  </br>

비선점형: 실행 중인 프로세스가 스스로 CPU를 반환할 때까지 실행됩니다. 강제로 중단되지 않으며, 컨텍스트 스위칭 오버헤드가 적습니다.  

선점형: 더 높은 우선순위를 가진 프로세스가 도착하면 현재 실행 중인 프로세스를 강제로 중단하고 CPU를 할당할 수 있습니다. 현대 운영체제에서 많이 사용됩니다.


</details>

<details>
  <summary>Q2. SJF와 SRTF의 차이는 무엇인가요?</summary>
  </br>
SJF : 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 방식입니다. 하지만 실행 중인 프로세스보다 더 짧은 작업이 도착해도 중단되지 않습니다.   

SRTF : 실행 중인 프로세스보다 실행 시간이 더 짧은 프로세스가 도착하면 현재 실행을 중단하고 새로운 프로세스를 실행합니다.

</details>

<details>
  <summary>Q3. 라운드 로빈 방식에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 발생하나요?</summary>

Time Quantum이 너무 크면 각 프로세스가 오래 실행되므로 FCFS와 유사해지고, 짧은 작업이 오래 대기할 가능성이 커집니다.  

Time Quantum이 너무 작으면 컨텍스트 스위칭이 빈번하게 발생하여 오버헤드가 증가하고, 시스템 성능이 저하될 수 있습니다.
</details>

## 📌 내용 정리
## CPU 스케줄링 알고리즘
> CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야하는 일을 ***스레드 단위***로 CPU에 할당한다.

## CPU 스케줄링 알고리즘의 목표  

- **CPU 이용률을 극대화**  
- **처리량(Throughput) 증가** (주어진 시간 내 최대한 많은 작업 수행)  
- **대기 시간 최소화** (Ready Queue에서 대기하는 프로세스를 줄임)  
- **응답 시간 최소화** (사용자가 명령을 입력한 후 응답받기까지의 시간을 단축)  

---

## 1. 비선점형(Non-preemptive) 스케줄링  
> **비선점형 스케줄링**은 프로세스가 스스로 CPU 소유권을 포기할 때까지 실행되는 방식이다.  
> 즉, 실행 중인 프로세스를 **강제로 중단하지 않는다**.  

장점: Context Switching(문맥 교환)이 적어 오버헤드가 낮음.  
단점: 특정 프로세스가 오래 실행되면 다른 프로세스가 오랫동안 대기해야 할 수도 있음.  

### FCFS (First Come, First Served) - **선입선출**  
> 가장 먼저 도착한 프로세스를 먼저 실행하는 방식  

**특징**  
- 간단한 구조로 구현이 쉬움.  
- **긴 실행 시간을 가진 프로세스가 먼저 실행될 경우, 뒤에 있는 프로세스가 오래 기다려야 하는 문제 발생** (**Convoy Effect**).  

### SJF (Shortest Job First) - **최단 작업 우선**  
> 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 방식  

**특징**  
- **평균 대기 시간이 가장 짧아 효율성이 높음**.  
- 하지만 **긴 실행 시간을 가진 프로세스는 계속 뒤로 밀릴 수 있음** (**Starvation 현상** 발생).  
- 실제로 실행 시간을 미리 알기 어렵기 때문에 **과거 실행 시간을 기반으로 예측하여 사용**.  

### 우선순위 (Priority)  
> 각 프로세스에 우선순위를 부여하여 높은 우선순위를 가진 프로세스를 먼저 실행하는 방식  

**특징**  
- **SJF의 Starvation 문제를 개선**하기 위해 오래된 프로세스의 우선순위를 높이는 **Aging 기법** 사용.  
- 우선순위 기준에 따라 실행 순서가 결정됨 (예: 프로세스 중요도, 입출력 대기 여부 등).  

---

## 2. 선점형(Preemptive) 스케줄링  
> **선점형 스케줄링**은 실행 중인 프로세스를 **강제로 중단**하고, 더 높은 우선순위를 가진 프로세스에 CPU를 할당하는 방식이다.  
> 대부분의 현대 운영체제에서 사용된다.  

장점: 긴 작업이 CPU를 독점하는 문제를 방지할 수 있음.  
단점: Context Switching이 많아지면 오버헤드가 증가함.  

### **라운드 로빈 (Round Robin, RR)**  
> 모든 프로세스에 동일한 Time Quantum(할당 시간)을 부여하고, 할당 시간이 지나면 다음 프로세스로 교체하는 방식  

**특징**  
- **시간이 고르게 분배되어 공평한 스케줄링을 보장**.  
- Time Quantum이 너무 크면 **FCFS와 유사해지고**, 너무 작으면 **Context Switching 오버헤드가 증가**.  
- 일반적으로 **전체 작업 시간이 증가하지만 평균 응답 시간은 감소**.  

**예시**  
- N개의 프로세스가 **q**만큼의 할당 시간을 가지면,  
  **(N - 1) × q 시간이 지나면 다시 자기 차례가 돌아옴**.  

### **SRTF (Shortest Remaining Time First)**  
> 기존 SJF와 유사하지만, 실행 중 더 짧은 실행 시간을 가진 프로세스가 도착하면 현재 실행 중인 프로세스를 중단하고 새로운 프로세스를 실행. SRF로도 쓰임.

**특징**  
- **SJF의 선점형 버전**으로, 평균 대기 시간이 더욱 짧아짐.  
- 하지만 **긴 작업이 계속 뒤로 밀려 Starvation이 발생할 가능성 있음**.  

### **다단계 큐 (Multilevel Queue)**  
> **여러 개의 Ready Queue를 사용**하여 우선순위에 따라 프로세스를 그룹화하는 방식  

**특징**  
- 각 큐는 **서로 다른 스케줄링 알고리즘을 적용할 수 있음** (예: 한 큐는 FCFS, 다른 큐는 RR).  
- **큐 간 이동이 불가능**하여 스케줄링 부담이 적지만, 유연성이 떨어질 수 있음.
