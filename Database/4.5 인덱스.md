# 인덱스

## 📌 면접 예상 질문

<details>
  <summary><strong>Q1. 데이터 베이스에서 인덱스를 사용하는 이유에 대해 설명해주세요.</strong></summary>
  </br>
 
 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위해서 사용합니다.

</details>

<details>
  <summary><strong>Q2. 인덱스의 장/단점을 설명해주세요.</strong></summary>
  </br>
  <strong>장점:</strong>

  - 데이터 검색 속도가 향상됩니다.  
  - 효율적인 쿼리 실행이 가능합니다.  
  - 특정 조건을 만족하는 데이터를 빠르게 찾을 수 있습니다.  
  - 정렬 및 그룹핑 작업에서 성능이 향상됩니다.  

  <strong>단점:</strong>  

  - 인덱스를 생성하면 추가적인 저장 공간이 필요합니다.  
  - 데이터 삽입, 수정, 삭제 시 인덱스를 갱신해야 하므로 성능이 저하될 수 있습니다.  
  - 너무 많은 인덱스를 사용하면 오히려 쿼리 성능이 저하될 수 있습니다.  

</details>

<details>
  <summary><strong>Q3. 인덱스를 사용하기 좋은 상황을 설명해주세요.</strong></summary>
  </br>

  - 대량의 데이터를 검색할 때 속도를 향상시키고 싶을 때  
  - WHERE 조건절에 자주 사용되는 열이 있을 때  
  - ORDER BY, GROUP BY 절을 자주 사용할 때  
  - 조인이 많이 발생하는 테이블에서 성능을 최적화하고 싶을 때  
  - 특정 컬럼을 기준으로 검색하는 빈도가 높을 때  

</details>


## 📌 내용 정리

### 1. 인덱스란?
>인덱스는 데이터를 빠르게 찾을 수 있는 색인으로, 책의 첫 장 혹은 마지막 장에 있는 "찾아보기"와 유사한 개념이다.

---

### 2. 인덱스의 구조
인덱스는 보통 **B-Tree** 자료구조를 기반으로 구성된다.

**🔹 B-Tree란?**
>B-트리는 **루트 노드**, **브랜치 노드**, 그리고 **리프 노드**로 이루어진 트리 구조이다.

- **루트 노드(Root Node)**: 트리의 최상단에 위치하며, 검색을 시작하는 지점이다.
- **브랜치 노드(Branch Node)**: 루트 노드와 리프 노드 사이에 위치하며, 데이터의 범위를 구분하는 역할을 한다.
- **리프 노드(Leaf Node)**: 최하단 노드로, 실제 데이터에 대한 포인터를 포함한다.

![B-트리 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdjhlni%2FbtrXnJAFNh0%2FmdqodQkO6khsmi3Z8seFQ1%2Fimg.png)

트리 탐색은 맨 위 루트 노드부터  
-> 브랜치 노드  
-> 리프 노드  
로 탐색. 찾는 값을 찾을때 까지 정렬된 값을 기반으로 `<=` 탐색한다.

**🔹 인덱스가 효율적인 이유**  
>인덱스가 효율적인 이유는 모든 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 트리구조와 트리 깊이의 대수확장성 때문.

| 트리 깊이 | 인덱스 항목 수 |
| --- | --- | 
| 3 | 64 | 
| 4 | 256 | 
| 5 | 1,024 | 
|...|...|
| 10 | 1,048,576 |
> 한 깊이가 증가할 때마다 인덱스 항목 수가 4배씩 증가한다. 

---

### 3. 인덱스 만드는 법
**🔹RDB (MySQL)**
a. 클러스터형 인덱스: 기본 키(Primary Key)로 자동 생성. 성능이 우수
b. 세컨더리 인덱스: 보조 인덱스로 여러 개의 필드 기반 쿼리를 수행할 때 유용
```sql
CREATE INDEX index_name ON table_name(column_name);
```

**🔹NoSQL (MongoDB)**
a. ObjectID가 기본 키로 자동 생성됨
b. 세컨더리 키를 설정하여 복합 인덱스로 구성 가능
```sql
db.collection.createIndex({ field_name: 1 });
```

---

## +)

### B+ Tree 자료구조

B+ Tree는 B-Tree를 개선한 형태의 자료구조로, 값이 리프 노드에만 저장되며 리프 노드들끼리는 링크드 리스트로 연결되어 있음. 이러한 구조 덕분에 범위 검색과 부등호 연산(>, <)에 효과적임.
 리프 노드를 제외한 모든 노드는 포인터 역할만 수행함.

---

### **파일 구성**
테이블 생성 시, 아래와 같은 3가지 파일이 생성됨.

- **FRM** : 테이블 구조 저장 파일
- **MYD** : 실제 데이터 파일
- **MYI** : 인덱스 정보 파일 (Index 사용 시 생성)

사용자가 인덱스를 사용하는 컬럼을 검색하면, MySQL은 **MYI 파일**의 내용을 활용하여 데이터를 빠르게 탐색.

---

### **B+ Tree의 단점**
- 인덱스를 생성하면 **.mdb 파일 크기**가 증가.
- 한 페이지를 동시에 수정할 수 있는 병행성이 감소.
- **인덱스된 필드**에서 데이터 업데이트, 레코드 추가 및 삭제 시 성능이 저하.
- 데이터 변경 작업이 빈번할 경우, **인덱스 재작성**이 필요하여 성능에 영향.

---

### **인덱스를 사용하면 좋은 경우**
1. **WHERE 절에서 자주 사용되는 컬럼**
2. **외래키(Foreign Key)로 사용되는 컬럼**
3. **JOIN에 자주 사용되는 컬럼**

### **인덱스 사용을 피해야 하는 경우**
1. **데이터 중복도가 높은 컬럼**
2. **DML(INSERT, UPDATE, DELETE)이 자주 발생하는 컬럼**

---

### DML이 일어났을 때의 상황
#### INSERT
기존 Block에 여유가 없을 때, 새로운 Data가 입력된다.

→ 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행한다.

→ Index split 작업 동안, 해당 Block의 Key 값에 대해서 DML이 블로킹 된다. (대기 이벤트 발생)

→ 이때 Block의 논리적인 순서와 물리적인 순서가 달라질 수 있다. (인덱스 조각화)

#### DELETE
<Table과 Index 상황 비교>

Table에서 data가 delete 되는 경우 : Data가 지워지고, 다른 Data가 그 공간을 사용 가능하다.

Index에서 Data가 delete 되는 경우 : Data가 지워지지 않고, 사용 안 됨 표시만 해둔다.

→ Table의 Data 수와 Index의 Data 수가 다를 수 있음

#### UPDATE
Table에서 update가 발생하면 → Index는 Update 할 수 없다.

Index에서는 Delete가 발생한 후, 새로운 작업의 Insert 작업 / 2배의 작업이 소요되어 힘들다.

---

### **Clustered Index vs. Non-Clustered Index**

#### **1. Clustered Index (클러스터 인덱스)**
- 인덱스로 지정한 컬럼을 기준으로 **데이터가 물리적으로 정렬**되는 인덱스.
- 한 테이블당 **하나만 존재**할 수 있으며, 기본적으로 **Primary Key**가 클러스터 인덱스로 설정됨.
- 검색 속도가 빠르지만, **INSERT, UPDATE, DELETE 성능이 상대적으로 느림**.

#### **2. Non-Clustered Index (비클러스터 인덱스)**
- 데이터 자체는 정렬되지 않고, **인덱스 값만 정렬**하여 새로운 인덱스 페이지를 생성하는 방식.
- 인덱스 페이지는 리프 페이지에서 **실제 데이터가 위치한 주소를 가리킴**.
- 한 테이블당 **여러 개 생성 가능**.
- 검색 속도는 클러스터 인덱스보다 느리지만, **INSERT, UPDATE, DELETE 성능이 상대적으로 빠름**.

