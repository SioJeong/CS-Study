# 조인의 원리

## 📌 면접 예상 질문

<details>
  <summary>Q1. 중첩 루프 조인과 블록 중첩 루프 조인의 차이는 무엇인가요? </summary>
  </br>
  <p>중첩 루프 조인은 한 테이블의 각 행을 다른 테이블의 모든 행과 비교하여 조인하는 방식입니다. 작은 테이블에서는 효과적이지만, 대용량 데이터에서는 랜덤 I/O가 많아 성능이 저하될 수 있습니다. <br>
    블록 중첩 루프 조인은 이를 개선한 방식으로, 여러 개의 행을 한 번에 메모리에 적재한 후 조인을 수행하여 성능을 향상시킵니다. 하지만, join_buffer_size보다 데이터가 크면 성능이 저하될 수 있어 인덱스를 활용하는 것이 더 효율적입니다.</p>
</details>

<details>
  <summary>Q2. 정렬 병합 조인과 해시 조인의 차이점은 무엇인가요?</summary>
  </br>
  <p>정렬 병합 조인은 조인할 두 테이블을 조인 키 기준으로 정렬한 후 병합하여 조인하는 방식으로, 범위 연산이 포함된 조인에 유리합니다. 하지만, 인덱스가 없으면 정렬 비용이 발생할 수 있습니다.<br>
  반면, 해시 조인은 조인 키를 해시 테이블로 변환하여 비교하는 방식으로, 동등 조인에서만 사용 가능하며, 대량의 데이터를 효율적으로 처리할 수 있습니다. 하지만 해시 테이블이 메모리에 모두 적재되지 않으면 성능이 저하될 수 있습니다.</p>
</details>

<details>
  <summary>Q3. 조인 성능을 최적화하는 방법은 무엇인가요?</summary>
  </br>
  <p>조인 성능을 최적화하기 위해서는 조인 키에 인덱스를 설정하여 풀 테이블 스캔을 방지하고, 데이터 크기가 작은 테이블을 먼저 읽는 것이 유리합니다.<br>
  또한, join_buffer_size나 sort_buffer_size를 적절히 조정하여 블록 중첩 루프 조인이나 정렬 병합 조인의 성능을 개선할 수 있습니다.</p>
</details>

<br>
<br>

## 📌 내용 정리
### 중첩 루프 조인 (NLJ, Nested Loop Join)
- 두 개의 테이블을 중첩 `for`문과 같은 원리로 **조건에 맞는 조인**을 하는 방법이다.
- 테이블의 레코드를 하나씩 읽고, 다른 테이블에서 해당 키와 일치하는 데이터를 검색한다.
- **랜덤 접근**에 대한 비용이 많이 증가하므로 **대용량의 테이블에서는 사용하지 않아야 한다.**
```sql
for each row in table1 matching reference key{
  for each row in table2 matching reference key{
    if row satisties join conditions, send to client // 조인 조건에 맞는 레코드만 전송
  }
}
```
- 최적화 방법
  - **조인 키에 인덱스 설정** : 인덱스 레인지 스캔(Index Range Scan)을 사용하여 특정 데이터만 접근이 가능하다.
  - **첫 번째로 선택된 테이블**(**드라이빙 테이블**)이 성능에 영향을 미치기 때문에 **데이터가 작은 테이블**을 먼저 선택한다.

<br>
<br>

### + ) 블록 중첩 루프 조인 (BNL, Block Nested Loop Join)
- 중첩 루프 조인의 확장된 형태로, 조인할 테이블을 **작은 블록으로 나눠서 블록 하나씩 조인**하는 방법이다.
- 여러 개의 레코드를 메모리에 적재한 후 한 번에 처리하기 때문에 성능이 향상된다.
- 조인 대상 테이블이 매우 크고 `join_buffer_size`보다 데이터 크기가 큰 경우 성능이 저하되므로, 인덱스를 활용하여 조인하는게 좋다.

<br>
<br>

### 정렬 병합 조인 (Sort-Merge Join)
- 각각의 테이블을 **조인할 필드 기준으로 정렬**하고 **정렬이 끝난 후 조인**을 수행하는 방법이다.
- **적절한 인덱스가 없고** 조인 조건으로 `<`, `>`, `BETWEEN` 등 범위 비교 연산자가 있을 때 사용한다.

<br>
<br>

### 해시 조인 (Hash Join)
- **해시 테이블**을 생성하여 **조인 키를 기반으로 해시**를 생성하고, 해시를 비교하여 조인하는 방법이다.
- 하나의 테이블이 **메모리에 온전히 들어간다면** 중첩 루프 조인보다 효율적이다.
- **동등(`=`) 조인**에서만 사용할 수 있다.

<br>
<br>

### MySQL의 해시 조인 
**1. 빌드 단계**
- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계이다.
- 두 개의 테이블을 조인할 때, 둘 중에 바이트가 더 작은 테이블을 기반으로 테이블을 빌드한다.
- 조인에 사용되는 필드가 해시 테이블의 키로 사용된다.

<br>

**2. 프로브 단계**
- 레코드 읽기를 시작하며, 각 레코드에서 키와 일치하는 레코드를 찾아서 반환한다.
- 각 테이블은 한 번씩만 읽게되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 성능이 좋은 경우가 많다.
- 사용 가능한 메모리 양은 시스템 변수 `join_buffer_size`에 의해 제어되며, 런타임 시에 조정 가능하다.

<br>
<br>

### join_buffer_size와 sort_buffer_size
- join_buffer_size
  - 조인 시 메모리에 저장할 수 있는 버퍼 크기를 설정하는 변수이다.
  - 인덱스가 없는 조인(특히, 블록 중첩 루프 조인)에서 사용된다.
  - 값이 작으면 디스크 I/O가 증가하여 성능이 저하될 수 있다.

- sort_buffer_size
  -  ORDER BY나 GROUP BY를 수행할 때 사용하는 정렬 버퍼 크기를 설정하는 변수이다.
  -  정렬해야 할 데이터가 많으면 값이 클수록 성능이 향상될 수 있다.
  -  하지만 너무 크면 메모리 낭비가 발생한다.
 
<br>
<br>

### 정리
| 조인 방식 | 장점 | 단점 | 최적화 포인트 |
|----------|------|------|--------------|
| **중첩 루프 조인** | 작은 테이블 조인 시 효과적, 인덱스 활용 가능 | 대용량 테이블 조인 시 성능 저하 가능 | 조인 키 인덱스 생성, 드라이빙 테이블 선정 |
| **블록 중첩 루프 조인** | 중첩 루프보다 성능 향상 | `join_buffer_size`보다 큰 데이터면 성능 저하 | `join_buffer_size` 조정, 인덱스 활용 검토 |
| **정렬 병합 조인** | 범위 조건 조인 시 유리 | 정렬 비용 발생 가능 | 인덱스 활용, `sort_buffer_size` 조정 |
| **해시 조인** | 동등(`=`) 조인에서 효과적 | 범위 조건 사용 불가, 메모리 초과 시 성능 저하 | `join_buffer_size` 최적화, 해시 테이블 크기 조정 |

  
