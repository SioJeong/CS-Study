# 비선형 자료 구조

## 📌 면접 예상 질문

<details>
  <summary>Q1. 트리와 그래프의 차이는 무엇인가요?</summary>
  </br>
  <p>트리는 그래프의 한 종류로, 사이클이 없는 연결 그래프입니다. 트리는 계층적 구조를 가지며, 부모-자식 관계가 명확하고, 노드 개수가 N개일 때 항상 N-1개의 간선을 가집니다.</p>
  <p>반면, 그래프는 정점과 간선으로 이루어진 일반적인 자료구조로, 사이클이 존재할 수도 있고 방향성이 있을 수도 있습니다. 또한, 그래프는 트리와 달리 루트 노드 개념이 없으며, 서로 연결되지 않은 정점이 존재할 수도 있습니다. </p>
</details>

<details>
  <summary>Q1. 우선순위 큐와 일반적인 큐의 차이점은 무엇인가요?</summary>
  </br>
  <p>일반적인 큐는 FIFO(First-In-First-Out) 구조를 따르며, 먼저 들어온 요소가 먼저 나갑니다. 하지만 우선순위 큐는 요소마다 우선순위를 부여하며, 우선순위가 높은 요소가 먼저 제공됩니다.</p>
  <p>우선순위 큐는 힙 자료구조를 기반으로 구현되는 경우가 많으며, 삽입과 삭제 연산이 O(logN)의 시간 복잡도를 가집니다.</p>
  <p>예를 들어, 운영체제의 작업 스케줄링이나 네트워크 패킷 처리 등에서 우선순위 큐가 활용됩니다.</p>
</details>

<details>
  <summary>Q2. 이진 탐색 트리와 레드-블랙 트리의 차이점은 무엇인가요?</summary>
  </br>
  <p>이진 탐색 트리는 노드의 정렬된 구조를 유지하여 탐색 속도를 향상시키는 트리 자료구조이지만, 한쪽으로 치우칠 경우 탐색, 삽입, 삭제 연산이 O(N)으로 성능이 저하될 수 있습니다.</p>
  <p>반면, 레드-블랙 트리는 균형을 유지하는 이진 탐색 트리로, 삽입 및 삭제 시 특정 규칙을 적용하여 균형을 유지됩니다. 모든 연산이 O(logN)으로 보장됩니다.</p>
</details>


## 📌 내용 정리
### 비선형 자료 구조
> 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조 ex) 트리, 그래프

<br>

### 그래프
> 정점과 간선으로 이루어진 자료 구조

<br>

#### 정점과 간선
- 어떠한 곳에서 어떠한 곳으로 무언가를 통해 간다고 했을 때
- 어떠한 곳 = **정점** = vertex
- 무언가 = **간선** = edge
- 간선은 양방향과 단방향이 있음
- 정점에서 나가는 간선을 해당 정점의 outdegree, 들어오는 간선을 indegree

<br>

#### 그래프의 종류
- **무방향 그래프**(Undirected Graph): 간선이 양방향
- **방향 그래프**(Directed Graph, DAG): 간선이 단방향
- **가중 그래프**(Weighted Graph): 간선에 가중치가 포함됨
- **연결 그래프**(Connected Graph): 모든 정점이 연결됨
- **비연결 그래프**(Disconnected Graph): 일부 정점이 연결되지 않음

<br>

#### 그래프 탐색 방법
- 너비 우선 탐색(BFS, Breadth-First Search): 큐(Queue)를 활용하여 같은 깊이의 정점을 먼저 탐색
- 깊이 우선 탐색(DFS, Depth-First Search): 스택(Stack) 또는 재귀 호출을 사용하여 한 경로를 끝까지 탐색 후 다른 경로 탐색

<br>
<br>

---

<br>
<br>

### 트리
> 그래프의 한 종류로, **계층적 데이터 구조**를 가지며 사이클이 없는 연결 그래프

<br>

#### 트리의 특징
- 부모, 자식 계층 구조를 가짐
- 간선 수 = 노드 수 - 1
- 임의의 두 노드 사이의 경로는 반드시 있음
- **루트 노드**(root node), **내부 노드**(internal node), **리프 노드**(leaf node)로 이루어짐

<br>

#### 루트 노드
- 가장 위에 있는 노드
- 보통 트리를 탐색할 때 루트 노드를 중심으로 탐색하면 편함

<br>

#### 내부 노드
- 루트 노드와 내부 노드 사이에 있는 노드

<br>

#### 리프 노트
- 자식 노드가 없는 노드

<br>

#### 트리의 높이와 레벨
- **깊이** : 트리에서의 깊이는 각 노드마다 다르며, **루트 노드**부터 **특정 노드**까지 **최단 거리**로 갔을 때의 거리를 의미
- **높이** : 트리의 높이는 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리를 의미
- **레벨** : 트리의 레벨은 보통 깊이와 같은 의미를 지님
- 서브트리 : 트리 내의 하위 집합을 서브트리라고 함

<br>

#### 이진 트리
> 자식의 노드 수가 두 개 이하인 트리를 의미

![image](https://github.com/user-attachments/assets/157b109d-9e2e-4444-aa33-5c6cfeb0ba15)
- **정이진 트리**(full) : 자식 노드가 0 또는 두 개인 이진 트리
- **완전 이진 트리**(complete) : 마지막 레벨을 제외하고는 모든 레벨이 채워져 있으며, 마지막 레벨은 왼쪽부터 채워진 이진 트리
- **변질 이진 트리**(degenerate) : 자식 노드가 하나 밖에 없는 이진 트리
- **포화 이진 트리**(perfect) : 모든 노드가 꽉 차 있는 이진 트리
- **균형 이진 트리**(balanced) : 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리, map, set을 구성하는 레드 블랙 트리는 균행 이진트리에 속함

<br>

#### 이진 탐색 트리
> 노드의 **오른쪽** 하위 트리에는 **노드 값보다 큰 값**, **왼쪽** 하위 트리에는 **노드 값보다 작은 값**이 들어있는 트리
- 요소를 찾을 때 탐색 트리의 경우 O(logN)
- 최악의 경우 O(N)
![image](https://github.com/user-attachments/assets/1c055507-ce44-4db5-8312-1a3e79a7825d)


<br>

#### AVL 트리
- 앞서 설명한 최악의 경우 선형적인 트리가 되는 것을 방지하고 **스스로 균형을 잡는 이진 탐색 트리** 
- 두 자식 서브트리의 높이는 항상 최대 1만큼 차이가 난다는 특징이 있음
- 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logN)
- 삽입, 삭제를 할 때마다 균형이 안 맞는 것을 맞추기 위해 **트리 일부를 왼쪽 혹은 오른쪽으로 회전**을 시키며 균형을 잡음

<br>

#### 레드 블랙 트리
- 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logN)
- 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하는데 사용
- C++ STL의 set, multiset, map, and multimap이 이를 이용하여 구현
- **모든 리프 노드와 루트 노드는 블랙, 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙** 규칙을 기반으로 균형을 잡음

<br>
<br>

---

<br>
<br>

### 힙
> **완전 이진 트리** 기반의 자료 구조, 최소힙과 최대힙이 있음
- **최소힙** : 루트 노드에 있는 키는 모든 자식에 있는 키 중에 최솟값
- **최대힙** : 루트 노드에 있는 키는 모든 자식에 있는 키 중에 최댓값

<br>

#### 힙의 연산
- **삽입** 연산
    - 완전 이진 트리 순서대로 노드가 삽입
    - 부모 노드의 값을 비교하여 부모 노드와 자리를 교환
- **삭제** 연산
    - 루트 노드가 삭제
    - 마지막 노드를 가져와 자식 노드들과 값을 비교하여 자리를 교환

<br>
<br>

---

<br>
<br>

### 우선순위 큐
> 우선순위가 높은 요소가 낮은 요소보다 먼저 제공되는 자료구조
- 배열(Array) 기반: 정렬된 배열로 구현 시, 삽입은 O(N), 삭제는 O(1)
- 연결 리스트(Linked List) 기반: 정렬된 연결 리스트 사용 시, 삽입 O(N), 삭제 O(1)
- 힙(Heap) 기반: 삽입과 삭제가 O(logN)으로 효율적


<br>
<br>

---

<br>
<br>

### 맵
> **키-값(Key-Value)** 쌍을 저장하는 자료 구조
- 해시 테이블(Hash Table) 또는 균형 이진 탐색 트리(Red-Black Tree)로 구현됨
- 빠른 검색과 데이터 접근을 위해 사용됨
<br>
<br>

---

<br>
<br>

### 셋
> 특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며 중복되는 요소가 없고 **유니크한 값만 저장**
- 해시 테이블(Hash Table) 또는 균형 이진 탐색 트리(Red-Black Tree)로 구현됨
- 원소의 중복을 허용하지 않으며, 탐색 및 삽입이 평균적으로 O(1) (해시 테이블 기반일 경우)
  
<br>
<br>

---

<br>
<br>

### 해시 테이블
> 키 값을 해시 함수를 통해 고유한 인덱스로 변환하여 데이터를 저장하는 자료 구조
- 평균적으로 삽입, 삭제, 탐색이 O(1)의 시간 복잡도를 가짐
- 충돌 해결 방법
  - 체이닝(Chaining): 같은 인덱스에 여러 값을 연결 리스트로 저장
  - 개방 주소법(Open Addressing): 충돌이 발생하면 비어있는 다른 위치를 찾아 저장
- 적용 사례: 캐싱 시스템, 데이터베이스 인덱싱, 중복 검사

<br>
<br>

---

<br>
<br>

### 정리
- **그래프**는 정점과 간선으로 이루어져 있으며 방향성과 가중치에 따라 여러 유형이 존재함
- **트리**는 그래프의 한 종류로 계층적 구조를 가지며, 이진 탐색 트리와 균형 이진 탐색 트리가 존재함
- **힙**과 **우선순위 큐**는 완전 이진 트리 기반으로 높은 우선순위를 가진 요소가 먼저 처리됨
- **맵, 셋, 해시 테이블**은 데이터를 효율적으로 저장하고 검색하는데 사용됨

